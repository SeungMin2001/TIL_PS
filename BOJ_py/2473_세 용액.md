```py
n=int(input())
data=list(map(int,input().split()))
data.sort()
answer=()
key=int(1e12)
for i in range(n-2):
    cur=i
    a=cur+1
    b=n-1
    while a<b:
        if abs(key)>abs(data[cur]+data[a]+data[b]):
            key=data[cur]+data[a]+data[b]
            answer=(data[cur],data[a],data[b])
        if data[cur]+data[a]+data[b]<0:
            a+=1
        elif data[cur]+data[a]+data[b]>0:
            b-=1
        else:
            print(data[cur],data[a],data[b])
            exit(0)

for i in answer:
    print(i,end=' ')

```
<h1>느낀점</h1>
투포인터 응용문제였는데 처음에 시간복잡도를 계산하는 과정에서 약간 계산실수를 했어서 시간이 좀 걸렸던 문제
문제조건상 파이썬 기준으로 1초로 주어졌는데 1초면 약 2000만번 이므로 시간복잡도가 2000만번 안에 들어가야 한다.
테스트케이스는 2000개. 즉 n^2이 나오면 2500만번 계산하므로 실패가 나올것이다. 
이번문제도 시간복잡도를 구해보면 정렬+두개의 반복문으로 n^2가 나오므로
NlogN + N^2이가 나온다. 근데 여기서 주의해야할 점은 시간복잡도는 큰 차수기준으로 하므로 식 안에 N의 차수가 2이면 무조건 N^2으로 표현할수 있는것이다.
그래서 이러한 논리로 풀겠다고 정했으면 좀더 상세하게 시간복잡도를 구해볼 필요가 있는것 같다.
자세히 구해보면 투포인터는 시간복잡도가 N일것이고 하나의 수를 고정한 상태에서 나머지 범위안에서 투포인터를 돌리는것이기 때문에
1부터 10까지를 예를들면 1~10, 2~10, 3~10 이렇게 비교수가 하나씩 줄어든다.
그래서 1/2 * (N(N-1)) 이 나온다. N^2이긴 하지만 1/2가 들어가므로 2500만번이 아니라 1250만번이 나온다.
여기에 N log N 도 5000*12정도라서 어림잡아도 6만쯤이 나온다. 충분히 가능한 복잡도이므로 
이 논리로 문제를 풀수 있게되는것이다.
